\documentclass{beamer}
\usepackage{amsmath}
\usepackage{array}
\usepackage{multirow}

\newenvironment{conditions}
  {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}{>{$}l<{$} @{${}={}$} l}}
  {\end{tabular}\par\vspace{\belowdisplayskip}}

\beamertemplatenavigationsymbolsempty{}
\usetheme{Goettingen}
\setbeamertemplate{footline}[frame number]
\usecolortheme{sidebartab}

%\setbeameroption{show only notes} % Only notes
%\setbeameroption{show notes on second screen=right} % Both

\mode<presentation>
\title[WebSocket]{Performance Evaluation of WebSocket Protocol for Implementation of Full-Duplex Web Streams}
\author{Oleg Bilovus}
\institute{Universit√† degli Studi di Salerno}
\date[SRF 1st]{1st Scalability Research Forum}

\begin{document}
\begin{frame}
    \titlepage{}
    \note{We will talk about WebSockets and compare its performance with TCP Socket. But, before diving into analyzing the performance we need to understand why we needed WebSockets and what they are.}
\end{frame}

\AtBeginSection[]{
    \begin{frame}
        \frametitle{Outline}
        \tableofcontents[currentsection,subsubsectionstyle=hide]
    \end{frame}
}

\section{Background}
\begin{frame}
    \frametitle{Background}
    \begin{itemize}[<+->]
        \item \emph{Historically}, creating \alert<+->{web applications} that need \alert<+->{bidirectional
                  communication} between a \alert<+->{client} and a \alert<+->{server} has required an \alert<+->{abuse of
                  HTTP to poll} the server for updates while sending upstream notifications as
              \alert<+->{distinct HTTP calls}.
              \note{Bidirectional means the server and the client can send data to each other at any time}
    \end{itemize}
\end{frame}

\subsection{HTTP polling}
\begin{frame}
    \frametitle{HTTP polling}
    Check whether the server is changed in a while, thereby performing incremental updates.
    \begin{columns}
        \begin{column}{0.7\textwidth}
            \begin{figure}
                \includegraphics[width=0.7\textwidth]{images/polling.jpeg}
            \end{figure}
        \end{column}
        \begin{column}<+->{0.35\textwidth}
            \begin{itemize}[<+->]
                \item How often to query?
                \item Continuously \alert{short interval} requests will be \alert{washed away} the
                      server. \note{A client can send data and ask for data at the same time. But, if
                          client has no data and server has no data, a request and response will still be
                          generated with all the HTTP headers and thus wasting resources.}
                \item \alert{Long interval} will require more time to reach the client, \alert{no real-time} data.
                      \note{No real-time data because while the client waits, an event could occur and the client will know about it only when the timeout expires.}
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\subsection{HTTP long polling}
\begin{frame}
    \frametitle{HTTP long polling}
    When a client sends a data request, the server will block the request until there is data transfer or timeout before returning.
    \begin{columns}
        \begin{column}{0.7\textwidth}
            \begin{figure}
                \includegraphics[width=0.7\textwidth]{images/long_polling.jpeg}
            \end{figure}
            \note{Can hold the connection up to a certain time, after that a timeout is exceeded and need a new connection.}
        \end{column}
        \begin{column}<+->{0.35\textwidth}
            \begin{itemize}[<+->]
                \item {\color{green} Solve the short polling frequency to access the server.}
                \item \alert{No bidirectional communication}, server push data.
                      \note{No bidirectional because the client may only send data the first time, but then it will only receive until a timeout and another request is made.}
                      \note{In the normal polling we could have bidirectional because the interval was shorter.}
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\subsection{Streaming}
\begin{frame}
    \frametitle{Streaming}
    Iframe embed a hidden frame in an HTML page, then set it as a long connection request, thus the server can send data to the clients constantly.
    \note{iframe is a html page inside another.}
    \begin{columns}
        \begin{column}{0.7\textwidth}
            \begin{figure}
                \includegraphics[width=0.7\textwidth]{images/streaming.jpeg}
            \end{figure}
        \end{column}
        \begin{column}<+->{0.35\textwidth}
            \begin{itemize}[<+->]
                \item It can send {\color{green} multiple events} from a {\color{green} single
                              request}.
                \item But, it increases the \alert{burden on the server}, causing the server
                      \alert{performance degradation}, or even collapse. \note{Because the server
                          need to keep the connections alive.}
                \item \alert{No bidirectional communication}.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\section{WebSocket protocol}

\subsection{Definition}
\begin{frame}
    \frametitle{RFC 6455}
    \framesubtitle{Keywords}
    \begin{itemize}[<+->]
        \item The WebSocket Protocol enables \alert<+->{two-way communication} between a
              \alert<+->{client} running untrusted code in a controlled environment to a
              \alert<+->{remote host} that has \alert<+->{opted-in} to communications from
              that code. \note{opted-in is important because with polling any HTTP server
                  would accept it, but here additional steps are needed.}
        \item The protocol consists of an opening \alert<+->{handshake} followed by basic
              \alert<+->{message framing}, layered over \alert<+->{TCP}. \note{Handshake
                  means client and server have to agree that they can both use the protocol and
                  the server has to prove it.} \note{Message framing because we do not want to
                  send every time the headers.} \note{TCP means it is reliable, no messages will
                  be lost.}
        \item The goal of this technology is to provide a mechanism for
              \alert<+->{browser-based} applications that need two-way communication with
              servers.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{WebSocket}
    \begin{figure}
        \includegraphics[width=0.8\textwidth]{images/WebSocket.jpeg}
    \end{figure}
    \note{There is the initial handshake, after that, client and server can send and receive data at any moment without further interaction.}
    \note{There is no timeout. If it disconnects, it is because of an error and to establish the connection, the handshake has to be done again.}
\end{frame}

\subsection{Handshake}
\begin{frame}
    \frametitle{Handshake}
    \begin{itemize}[<+->]
        \item For WebSocket-based communication, a \alert{WebSocket session} should be
              established first.
        \item To establish a session, client sends a WebSocket \alert{Upgrade Request} to the
              server, upon which server responds with a WebSocket \alert{Upgrade Response}.
              \note{With the Upgrade Response, the server proves that it can communicate with
                  WebSockets.}
        \item From this point forward, the client and server can \alert{send data back and
                  forth in asynchronous full-duplex mode}.
    \end{itemize}
\end{frame}

\subsubsection{Upgrade Request}
\begin{frame}
    \frametitle{WebSocket Upgrade Request}
    \begin{columns}
        \begin{column}{0.6\textwidth}
            \texttt{\alert<2>{GET} \alert<3>{/chat} \alert<2>{HTTP/1.1}\\
                Host: server.example.com\\
                \alert<4>{Upgrade: WebSocket}\\
                \alert<4>{Connection: Upgrade}\\
                \alert<5>{Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==}\\
                Origin: http://example.com\\
                \alert<6>{Sec-WebSocket-Protocol: chat, superchat}\\
                \alert<7>{Sec-WebSocket-Version: 13}
            }
        \end{column}
        \begin{column}<+->{0.45\textwidth}
            \begin{itemize}
                \item<2-| alert@2> HTTP GET request.
                \item<3-| alert@3> URI to identify endpoint.
                      \note{Different URI can be used to identify different endpoints. A URI can be regular HTTP, another can be WebSocket.}
                \item<4-| alert@4> Headers indicating the will to switch from regular HTTP to WebSocket.
                \item<5-| alert@5> A key the server has to use to prove that it can use WebSockets.
                \item<6-| alert@6> WebSocket protocols.
                \item<7-| alert@7> WebSocket version.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\subsubsection{Upgrade Response}
\begin{frame}
    \frametitle{WebSocket Upgrade Response}
    \begin{columns}
        \begin{column}{0.6\textwidth}
            \texttt{HTTP/1.1 \alert<2>{101 Switching protocols}\\
                \alert<2>{Upgrade: WebSocket}\\
                \alert<2>{Connection: Upgrade}\\
                \alert<3>{Sec-WebSocket-Accept: dGhlIHNhbXBsZSBub25jZQ==}\\
                Origin: http://example.com\\
                \alert<4>{Sec-WebSocket-Protocol: chat}
            }
        \end{column}
        \begin{column}<+->{0.45\textwidth}
            \begin{itemize}
                \item<2-| alert@2> Server confirms it supports WebSocket.
                \item<3-| alert@3> Server proves that it can use WebSocket. Client checks it.
                      \note{There is a specific algorithm to generate this Header from a key.}
                \item<4-| alert@4> Server tells which protocol it supports.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\subsection{Frame}
\begin{frame}
    \frametitle{WebSocket Frame}
    \begin{itemize}[<+->]
        \item After the handshake is successful, client and server can \alert{communicate in
                  full-duplex} by using frames.
        \item The added \alert{overhead} to the payload data is \alert{minimal} because it
              does not send all the HTTP headers for each frame.
        \item Each frame adds \alert{at least 2 bytes of overhead} to the payload data.
              Depending on the length of the payload data and the direction of the
              communication, the length of the overhead \alert{may increase up to 14 bytes}.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{WebSocket Frame Structure}
    \note{We will not go into the details because it is out of the scope of this presentation and, as mentioned earlier, the added overhead to the payload data is minimal.}
    \begin{figure}
        \includegraphics[width=1\textwidth]{images/message_frame.png}
    \end{figure}
\end{frame}

\subsection{API}
\begin{frame}
    \frametitle{WebSocket API}
    The API is defined by its states of readiness, responses to a networking or messaging \alert{event}.
    \begin{table}
        \centering
        \begin{tabular}{|c | p{0.6\linewidth}|}
            \hline
            \textbf{Callback}  & \textbf{Description}                                                                                                   \\
            \hline
            \hline
            \texttt{onopen}    & invoked when WebSocket \texttt{session is established}, signalizes that the protocol is ready to transfer payload data \\
            \hline
            \texttt{onerror}   & invoked whenever an \texttt{error occurs}                                                                              \\
            \hline
            \texttt{onclose}   & invoked when one of the peers has \texttt{terminated the session}                                                      \\
            \hline
            \texttt{onmessage} & invoked when an \texttt{incoming message} from another peer has arrived                                                \\
            \hline
        \end{tabular}
    \end{table}
\end{frame}

\section{Performance vs TCP Socket}
\note{We will now try to evaluate the WebSocket performance compared to the raw TCP Socket.}
\subsection{Performance Evaluation}
\begin{frame}
    \frametitle{Performace Evaluation}
    \begin{itemize}[<+->]
        \item Performance evaluation of the WebSocket and the TCP Socket protocol consists
              of:
              \begin{itemize}[<+->]
                  \item Network traffic
                  \item Data transfer time
              \end{itemize}
        \item Network traffic is \textit{evaluated analytically} using the protocol
              specifications.
        \item Data transfer time is \textit{evaluated experimentally} in a laboratory test
              bed.
    \end{itemize}
\end{frame}

\subsection{WebSocket sequence diagram}
\begin{frame}[label=ws_seq_diag]
    \frametitle{WebSocket sequence diagram}
    \note{WebSocket stay on top of TCP which means it will always add more overhead than the raw TCP Socket, but WebSocket is easier to use in a web environment.}
    \begin{figure}
        \includegraphics[width=0.9\textwidth]{images/websocket_seq_diagram.jpeg}
    \end{figure}
\end{frame}

\subsection{Network traffic}
\begin{frame}
    \frametitle{Analytical Evaluation of Network Traffic}
    \begin{itemize}[<+->]
        \item Both protocols will have the lower level protocols fields overhead such as
              \textit{Ethernet, IP and TCP header}.
        \item For this reason, the analysis consider only the overhead the WebSocket incurs:
              \begin{itemize}[<+->]
                  \item Handshake
                  \item Frame header for each frame
              \end{itemize}
    \end{itemize}
\end{frame}

\subsubsection{Handshake overhead}
\begin{frame}
    \frametitle{Handshake overhead}
    \begin{figure}
        \includegraphics[width=0.9\textwidth]{images/websocket_handshake_overhead.jpeg}
    \end{figure}
    \pause{}
    \begin{itemize}[<+->]
        \item The overhead is \alert{fixed in length} and typically counts few hundreds of
              bytes.
        \item It is \alert{performed only once} per session.
        \item Its \alert{significance decreases} with the increasing number of frames sent
              over the same session. Thus, the evaluation is focused on long-running
              sessions.
    \end{itemize}
\end{frame}

\subsubsection{Frame overhead}
\begin{frame}
    \frametitle{Frame overhead}
    \begin{figure}
        \includegraphics[width=0.9\textwidth]{images/websocket_frame_overhead.jpeg}
    \end{figure}
    \pause{}
    \begin{itemize}[<+->]
        \item The overhead counts \alert{2 to 14 bytes} for each frame.
    \end{itemize}
\end{frame}

\subsubsection{Results}
\begin{frame}
    \frametitle{Results}
    \begin{itemize}[<+->]
        \item When the data are transferred with TCP Socket, they are \alert{directly
                  embedded as TCP Payload}.
        \item With WebSocket, the TCP Payload consists of both data and Frame header.
        \item This relation can be written as:
              \begin{equation}
                  P_{TCP} = data
              \end{equation}
              \begin{equation}
                  P_{WS} = data + H
              \end{equation}
              where:
              \begin{conditions}
                  P    & payload                 \\
                  data & data to send            \\
                  H    & length of frame's header
              \end{conditions}
        \item We can now define the \alert{network traffic overhead $O_P$} a WebSocket has
              over a TCP Socket:
              \begin{equation}
                  O_P = \frac{P_{WS} - P_{TCP}}{P_{TCP}}\cdot 100\%
              \end{equation}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Results}
    \begin{figure}
        \includegraphics[width=0.9\textwidth]{images/network_traffic_overhead.jpeg}
    \end{figure}
    \pause{}
    \begin{itemize}[<+->]
        \item \alert{Significant difference} in performance only for \alert{tiny data}.
              \note{Because if I want to send 1 byte, with WebSocket it will could add 14 bytes of frame header.}
        \item For \alert{biggest messages}, the WebSocket frame size \alert{converges very
                  fast} towards the TCP Socket size. \note{The difference is smaller and smaller
                  because 14 bytes of overhead on a 1 KB data is nothing.}
        \item Except for the \textit{initial} WebSocket Handshake, \alert{the amount of
                  network traffic generated is comparable to that generated by to the TCP Socket.
                  \note{The difference is almost identical.} }
    \end{itemize}
\end{frame}

\subsection{Data Transfer Time}
\begin{frame}
    \frametitle{Experimental Evaluation of Data Transfer Time}
    \begin{itemize}[<+->]
        \item Two host machines.
        \item One playing the role of the server.
        \item While the other being a client.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Environment configuration}
    \begin{table}
        \begin{tabular}{| p{0.2\linewidth}|p{0.3\linewidth}|p{0.3\linewidth} |}
            \hline
                                              & \textbf{Client}                                                                                                                            & \textbf{Server}                                   \\
            \hline
            \hline
            \textbf{Hardware}                 & CPU: AMD Turion II P520 \newline RAM: 6 GB                                                                                                 & CPU: AMD Athlon X2 5000 \newline RAM: 5 GB        \\
            \hline
            \textbf{OS}                       & Windows 8 64-bit                                                                                                                           & Windows 8 64-bit                                  \\
            \hline
            \textbf{Network}                  & \multicolumn{2}{p{0.6\linewidth}|}{1000BASE-T (Gigabit Ethernet, \textbf{host machines directly connected} using UTP Cat5 Ethernet cable)}                                                     \\
            \hline
            \textbf{TCP implementation}       & \textit{java.net.Socket} (Java JDK 1.7)                                                                                                    & \textit{java.net.Socket} (Java JDK 1.7)           \\
            \hline
            \textbf{WebSocket implementation} & \textit{websocket.\textbf{client}} (Jetty 9.1.0)                                                                                           & \textit{websocket.\textbf{servlet}} (Jetty 9.1.0) \\
            \hline
        \end{tabular}
    \end{table}
\end{frame}

\subsubsection{Connection}
\begin{frame}
    \frametitle{TCP Connection and WebSocket session time}
    In the first experiment, it is measured the time required for client and server to establish a TCP connection and WebSocket session.
    \pause{}
    \begin{figure}
        \includegraphics[width=0.7\textwidth,height=0.5\textheight]{images/data_time_connection.jpeg}
    \end{figure}
    \begin{itemize}
        \item WebSocket session lasts \alert{3.7 times longer} than establishing a TCP
              connection.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{TCP Connection and WebSocket session time}
    \begin{itemize}[<+->]
        \item The reason for such slow performance of the WebSocket is the fact that the
              protocol is not a \textit{transport protocol}.
        \item WebSocket sits on top of TCP and uses HTTP for the handshake.
        \item Which means it first has to establish a TCP connection, allocate the resource
              for HTTP and then can establish a WebSocket handshake. \note{We have already
                  seen this previously.}
    \end{itemize}
\end{frame}

\againframe{ws_seq_diag}

\subsubsection{Data}
\begin{frame}
    \frametitle{Data transfer time after connection}
    \begin{itemize}[<+->]
        \item In the second experiment, it is measured the data transfer time after the TCP
              connection and WebSocket session have been established.
        \item The Client generates a given amount of data and sends them to the server.
        \item The Server echoes the same data back to the client.
        \item It is possible to define the \alert{relative time overhead $O_T$} a WebSocket
              incurs over TCP as:
              \begin{equation}
                  O_T = \frac{T_{WS} - T_{TCP}}{T_{TCP}}\cdot 100\%
              \end{equation}
              where:
              \begin{conditions}
                  T & time to transfer data
              \end{conditions}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Data transfer time after connection}
    \begin{figure}
        \includegraphics[width=0.9\textwidth,height=0.8\textwidth]{images/data_transfer_time.jpeg}
    \end{figure}
\end{frame}

\begin{frame}
    \frametitle{Data transfer time after connection}
    \begin{itemize}[<+->]
        \item The WebSocket performs slower than the TCP.
        \item The performance drop is more significant for small messages.
        \item The overhead of WebSocket \textit{fluctuates} between 150\% and 250\% for small
              messages.
        \item For biggest messages, the overhead is more \textit{stable} at 60-70\%.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Why WebSocket performs slower?}
    \begin{itemize}[<+->]
        \item WebSocket sits on top of TCP.
        \item WebSocket uses event-driven callback-based API to deliver data, which requires
              additional application data handling.
        \item In 2014, the WebSocket protocol emerged just a few years before with little
              production systems deployed. While TCP has been used in production for decades
              and has highly optimized libraries.
    \end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}
    \begin{itemize}[<+->]
        \item As expected, TCP slightly outperforms WebSocket because the WebSocket sits on
              top of it.
        \item The amount of generated network traffic is almost the same.
        \item The difference in data transfer time is remarkable.
        \item The advantages of the WebSocket protocol is its alignment with the existing Web
              infrastructure, where low-level TCP protocol is not directly applicable.
    \end{itemize}
\end{frame}

\begin{frame}
    \nocite{*}
    \frametitle{References}
    \bibliographystyle{amsalpha}
    \bibliography{bib.bib}
\end{frame}
\end{document}